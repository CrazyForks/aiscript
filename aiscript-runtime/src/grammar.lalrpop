use std::str::FromStr;
use std::collections::HashMap;

use lalrpop_util::ParseError;

use crate::ast::*;
use crate::lalrpop_helpers::*;

grammar;

extern {
    type Error = String;
}

pub Route: Route = {
    "route" <path: Path> "{" <endpoints: Endpoint*> "}" => Route {
        prefix: path.0,
        params: path.1,
        endpoints,
    },
    <endpoints: Endpoint*> => Route {
        prefix: "".to_string(),
        params: Vec::new(),
        endpoints,
    }
};

Endpoints: Vec<Endpoint> = {
    <endpoints: Endpoint*> => <>
}

Endpoint: Endpoint = {
     <path_specs:PathSpecs> <body:RouteBody> => Endpoint {
        path_specs,
        return_type: None,
        query: body.query,
        body: body.body,
        handler: Handler::Empty,
    }
};

PathSpecs: Vec<PathSpec> = {
    <paths:(<PathSpec> ",")*> <last:PathSpec> => {
        let mut paths = paths;
        paths.push(last);
        paths
    }
};

PathSpec: PathSpec = {
    <method:HttpMethod> <path:Path> => PathSpec {
        method,
        path: path.0,
        params: path.1,
    }
};

HttpMethod: HttpMethod = {
    "get" => HttpMethod::Get,
    "post" => HttpMethod::Post,
    "put" => HttpMethod::Put,
    "delete" => HttpMethod::Delete,
};

// Example of how paths are parsed:
// "/users/<id:int>/posts"
// Gets broken down into segments:
// - Static("users")
// - Parameter(PathParameter { name: "id", param_type: "int" })
// - Static("posts")
// Grammar rules for path parsing remain the same:
Path: (String, Vec<PathParameter>) = {
    <segments:PathSegment*> =>? {
        if segments.is_empty() {
            return Err(ParseError::User{ error: "Path required after http method".into() })
        }
        let path = segments.iter()
            .map(|s| match s {
                PathSegmentKind::Static(s) => format!("/{}", s),
                PathSegmentKind::Parameter(p) => format!("/:{}", p.name),
            })
            .collect::<Vec<_>>()
            .join("");
        let path = if path.is_empty() { "/".to_string() } else { path };
        let params = segments.iter()
            .filter_map(|s| match s {
                PathSegmentKind::Parameter(p) => Some(p.clone()),
                _ => None,
            })
            .collect();
        Ok((path, params))
    }
};

PathSegment: PathSegmentKind = {
    "/" => PathSegmentKind::Static(String::new()),
    "/" <s:r"[a-zA-Z][a-zA-Z0-9_]*"> => PathSegmentKind::Static(s.to_string()),
    "/" "<" <name:Identifier> ":" <typ:PathParameterType> ">" => PathSegmentKind::Parameter(PathParameter {
        name: name.to_string(),
        param_type: typ.to_string(),
    }),
};

PathParameterType: String = {
    "int" => <>.to_string(),
    "str" => <>.to_string(),
    "bool" => <>.to_string(),
}

RouteBody: RouteBodyParts = {
    "{" <parts:RoutePart*> "}" => {
        let mut query = Vec::new();
        let mut body = RequestBody::default();
        // let mut handler_code = String::new();
        
        // FIXME: only one query and one body is allowed
        for part in parts {
            match part {
                RoutePartKind::Query(q) => query = q,
                RoutePartKind::Body(b) => body = b,
                // RoutePartKind::Code(c) => handler_code = c,
            }
        }
        
        RouteBodyParts {
            query,
            body,
            // handler_code,
        }
    }
};

RoutePart: RoutePartKind = {
    <q:QueryBlock> => RoutePartKind::Query(q),
    <b:BodyBlock> => RoutePartKind::Body(b),
    // <c:HandlerCode> => RoutePartKind::Code(c),
};

QueryBlock: Vec<Field> = {
    "query" "{" <fields:Field*> "}" => fields,
};

BodyBlock: RequestBody = {
    "body" "{" <fields:Field*> "}" => RequestBody {
        kind: BodyKind::Json,
        fields,
    },
    <kind:BodyDirective> "body" "{" <fields:Field*> "}" => RequestBody {
        kind,
        fields,
    }
};

// HandlerCode: String = {
//     <s:(!("query" | "body") !"{" !"}" [_])*> => <>.iter().collect()
// };

BodyDirective: BodyKind = {
    "@json" => BodyKind::Json,
    "@form" => BodyKind::Form,
};

Field: Field = {
    <directives:(<Directive>)*>
    <name:Identifier> ":" <typ:FieldType> <default:("=" <Value>)?> => Field {
        name: name.to_string(),
        _type: typ,
        required: default.is_none(),
        default,
        directives,
    }
};

FieldType: FieldType = {
    "int" => FieldType::Number,
    "str" => FieldType::Str,
    "bool" => FieldType::Bool,
}

Directive: Directive = {
    AnyDirective,
    NotDirective,
    SimpleDirective,
};

// @any requires 2 or more directives
AnyDirective: Directive = {
    "@any" "(" <first:Directive> "," <second:Directive> <rest:("," <Directive>)*> ")" => {
        let mut directives = vec![first, second];
        directives.extend(rest);
        Directive::Any(directives)
    },
};

NotDirective: Directive = {
    "@not" "(" <d:Directive> ")" => Directive::Not(Box::new(d)),
};

SimpleDirective: Directive = {
    "@" <name:Identifier> "(" <params:DirectiveParams> ")" => Directive::Simple {
        name: name.to_string(),
        params,
    },
    "@" <name:Identifier> => Directive::Simple {
        name: name.to_string(),
        params: HashMap::new(),
    },
};

DirectiveParams: HashMap<String, serde_json::Value> = {
    <params:Comma<DirectiveParam>> => params.into_iter().collect()
};

DirectiveParam: (String, serde_json::Value) = {
    <name:Identifier> "=" <value:Value> => (name.to_string(), value)
};

Value: serde_json::Value = {
    StringLiteral => serde_json::Value::String(<>),
    Num => serde_json::Value::Number(<>.into()),
    "true" => serde_json::Value::Bool(true),
    "false" => serde_json::Value::Bool(false),
};

HandlerBody: String = {
    "{" <content:HandlerContent> "}" => content.trim().to_string()
};

HandlerContent: String = {
    <parts:HandlerPart*> => parts.join("")
};

HandlerPart: String = {
    // BODY_TEXT => <>.to_string(),
    "{" <content:HandlerContent> "}" => format!("{{{}}}", content),
};

Identifier: &'input str = r"[a-zA-Z][a-zA-Z0-9_]*" => <>;
StringLiteral: String = <s:r#""[^"]*""#> => s[1..s.len()-1].to_string();
Num: i64 = r"-?[0-9]+" => i64::from_str(<>).unwrap();
// Type: &'input str = r"[a-zA-Z][a-zA-Z0-9_\.]*" => <>;

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};