use std::str::FromStr;

use crate::ast::*;
use crate::lalrpop_helpers::*;

grammar;

pub Endpoint: Endpoint = {
     <path_specs:PathSpecs>  <body:RouteBody> => Endpoint {
        path_specs,
        return_type: None,
        query: body.query,
        body: body.body,
        handler: Handler::Empty,
    }
};

PathSpecs: Vec<PathSpec> = {
    <paths:(<PathSpec> ",")*> <last:PathSpec> => {
        let mut paths = paths;
        paths.push(last);
        paths
    }
};

PathSpec: PathSpec = {
    <method:HttpMethod> <path:Path> => PathSpec {
        method,
        path: path.0,
        path_params: path.1,
    }
};

HttpMethod: HttpMethod = {
    "get" => HttpMethod::Get,
    "post" => HttpMethod::Post,
    "put" => HttpMethod::Put,
    "delete" => HttpMethod::Delete,
};

// Example of how paths are parsed:
// "/users/<id:int>/posts"
// Gets broken down into segments:
// - Static("users")
// - Parameter(PathParameter { name: "id", param_type: "int" })
// - Static("posts")

// Grammar rules for path parsing remain the same:
Path: (String, Vec<PathParameter>) = {
    <segments:PathSegment*> "/"? => {
        let path = segments.iter()
            .map(|s| match s {
                PathSegmentKind::Static(s) => format!("/{}", s),
                PathSegmentKind::Parameter(p) => format!("/:{}", p.name),
            })
            .collect::<Vec<_>>()
            .join("");
        let path = if path.is_empty() { "/".to_string() } else { path };
        let params = segments.iter()
            .filter_map(|s| match s {
                PathSegmentKind::Parameter(p) => Some(p.clone()),
                _ => None,
            })
            .collect();
        (path, params)
    }
};

PathSegment: PathSegmentKind = {
    "/" <s:r"[a-zA-Z][a-zA-Z0-9_]*"> => PathSegmentKind::Static(s.to_string()),
    "/" "<" <name:Identifier> ":" <typ:PathParameterType> ">" => PathSegmentKind::Parameter(PathParameter {
        name: name.to_string(),
        param_type: typ.to_string(),
    }),
};

PathParameterType: String = {
    "int" => <>.to_string(),
    "str" => <>.to_string(),
    "bool" => <>.to_string(),
}

RouteBody: RouteBodyParts = {
    "{" <parts:RoutePart*> "}" => {
        let mut query = Vec::new();
        let mut body = None;
        // let mut handler_code = String::new();
        
        for part in parts {
            match part {
                RoutePartKind::Query(q) => query = q,
                RoutePartKind::Body(b) => body = Some(b),
                // RoutePartKind::Code(c) => handler_code = c,
            }
        }
        
        RouteBodyParts {
            query,
            body,
            // handler_code,
        }
    }
};

RoutePart: RoutePartKind = {
    <q:QueryBlock> => RoutePartKind::Query(q),
    <b:BodyBlock> => RoutePartKind::Body(b),
    // <c:HandlerCode> => RoutePartKind::Code(c),
};

QueryBlock: Vec<Field> = {
    "query" "{" <fields:Field*> "}" => fields,
};

BodyBlock: RequestBody = {
    "body" "{" <fields:Field*> "}" => RequestBody {
        kind: BodyKind::Json,
        fields,
    },
    <kind:BodyDirective> "body" "{" <fields:Field*> "}" => RequestBody {
        kind,
        fields,
    }
};

// HandlerCode: String = {
//     <s:(!("query" | "body") !"{" !"}" [_])*> => <>.iter().collect()
// };

BodyDirective: BodyKind = {
    "@json" => BodyKind::Json,
    "@form" => BodyKind::Form,
};

Field: Field = {
    <validations:(<Directive>)*>
    <name:Identifier> ":" <typ:PathParameterType> => Field {
        name: name.to_string(),
        _type: FieldType::Str,
        required: true,
        default: None,
        validators: validations,
    }
};

Directive: Directive = {
    AnyDirective,
    NotDirective,
    SimpleDirective,
};

// @any requires 2 or more directives
AnyDirective: Directive = {
    "@any" "(" <first:Directive> "," <second:Directive> <rest:("," <Directive>)*> ")" => {
        let mut directives = vec![first, second];
        directives.extend(rest.into_iter());
        Directive::Any(directives)
    },
};

NotDirective: Directive = {
    "@not" "(" <d:Directive> ")" => Directive::Not(Box::new(d)),
};

SimpleDirective: Directive = {
    "@" <name:Identifier> "(" <params:DirectiveParams> ")" => Directive::Simple {
        name: name.to_string(),
        params,
    },
    "@" <name:Identifier> => Directive::Simple {
        name: name.to_string(),
        params: vec![],
    },
};

DirectiveParams: Vec<DirectiveParam> = {
    <params:Comma<DirectiveParam>> => params
};

DirectiveParam: DirectiveParam = {
    <name:Identifier> "=" <value:DirectiveValue> => DirectiveParam::Named {
        name: name.to_string(),
        value,
    },
    <value:DirectiveValue> => DirectiveParam::Positional(value),
};

DirectiveValue: DirectiveValue = {
    StringLiteral => DirectiveValue::String(<>),
    Num => DirectiveValue::Number(<>),
    "true" => DirectiveValue::Boolean(true),
    "false" => DirectiveValue::Boolean(false),
};

HandlerBody: String = {
    "{" <content:HandlerContent> "}" => content.trim().to_string()
};

HandlerContent: String = {
    <parts:HandlerPart*> => parts.join("")
};

HandlerPart: String = {
    // BODY_TEXT => <>.to_string(),
    "{" <content:HandlerContent> "}" => format!("{{{}}}", content),
};

Identifier: &'input str = r"[a-zA-Z][a-zA-Z0-9_]*" => <>;
StringLiteral: String = <s:r#""[^"]*""#> => s[1..s.len()-1].to_string();
Num: i64 = r"-?[0-9]+" => i64::from_str(<>).unwrap();
// Type: &'input str = r"[a-zA-Z][a-zA-Z0-9_\.]*" => <>;

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};